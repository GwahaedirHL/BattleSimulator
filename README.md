# BattleSimulator
Тестовое задние Z - media (Unity development)

Время выполнения 24ч

# Общее описание

Проект представляет собой симуляцию боя между двумя армиями, реализованную в Unity с использованием Unity Entities (ECS) для геймплея и MVC-подхода для пользовательского интерфейса.

## Архитектура

Проект использует гибридную архитектуру:

 - Gameplay — Unity ECS (Entities 1.x)
 - UI — MVC поверх MonoBehaviour
 - Связь UI ↔ ECS — через request-компоненты и события

 Использование ECS и DOTS, с применением Burst, позволяет легко масштабировать проекти спавнить на сцене большое количество юнитов (тысячи) без потери прозводительности.
 UI сторона общается с ECS стороной по средством компонентов-реквестов для вызова реакций со стороны систем.

## Архитектура проекта

Проект построен на **гибридной архитектуре**, сочетающей **Unity ECS (Entities 1.x)** для геймплейной симуляции и **MVC-подход** для пользовательского интерфейса. Такое разделение позволяет эффективно масштабировать симуляцию и при этом сохранить простой и поддерживаемый UI-код.

---

### Общая схема

- **Gameplay-слой**  
  Реализован полностью на ECS и отвечает за:
  - спавн юнитов,
  - поиск и выбор целей,
  - движение,
  - атаку и урон,
  - проверку окончания боя,
  - дополнительные геймплейные события (метеор).

- **UI-слой**  
  Реализован на MonoBehaviour с использованием MVC:
  - View — отображение состояния игры,
  - Controller — обработка пользовательских действий,
  - Model (UI) — локальные UI-состояния (например, cooldown).

- **Связь UI ↔ ECS**  
  Осуществляется через:
  - ECS request-компоненты (one-frame события),
  - события (events) из ECS в UI.

---

### Gameplay (ECS)

#### Типы компонентов
- **Данные юнита**  
  `HealthComponent`, `AttackComponent`, `SpeedComponent`,  
  `AttackRangeComponent`, `AttackSpeedComponent`, `AttackCooldownComponent`

- **Теги и состояние**  
  `ArmyOneTag`, `ArmyTwoTag`, `GameStartedTag`,  
  `TargetLockedData`, `RetargetData`

- **Request-компоненты**  
  Используются как события:
  - `SpawnRequest`
  - `MeteorSpawnRequest`
  - `MeteorMovementRequest`
  - `MeteorImpactRequest`

---

#### Основные системы

- **SpawnSystem**  
  Создаёт юнитов двух армий при старте боя на основе данных из authoring-компонентов.

- **TargetAcquireGridSystem**  
  Выполняет поиск ближайшей цели с использованием grid-based spatial hashing.  
  Позволяет избежать O(N²) перебора при большом количестве юнитов.

- **MoveToTargetSystem**  
  Отвечает за движение юнитов к цели:
  - использует Jobs + Burst,
  - учитывает минимальную дистанцию,
  - реализует избегание союзников (separation).

- **AttackSystem**  
  Обрабатывает атаку:
  - проверяет дистанцию,
  - учитывает cooldown атаки,
  - уменьшает здоровье цели.

- **RetargetStuckSystem**  
  Обнаруживает ситуации, когда юнит перестал эффективно сближаться с целью,  
  и инициирует поиск новой цели.

- **CheckEndBattleSystem**  
  Отслеживает количество юнитов в армиях и определяет победителя.  
  Уведомляет UI через event.

---

### Дополнительная механика: Метеор (ECS)

Механика реализована через request-based подход:

- `MeteorSpawnRequest` — запрос от UI
- `MeteorSpawnSystem` — создаёт метеор
- `MeteorMovementSystem` — управляет падением
- `MeteorImpactSystem` — наносит AoE-урон юнитам в радиусе

Параметры метеора (радиус, урон, позиция) задаются через `MeteorSpawnerAuthoring`.

---

### UI-слой (MVC)

#### View
- **GameUI**
  - кнопка вызова метеора,
  - индикатор кулдауна,
  - экран победы,
  - кнопка возврата в меню.

- **MainMenu**
  - генерация армий,
  - отображение состава,
  - запуск сцены боя.

---

#### Controller
- **GameUiController**
  - подписывается на события UI,
  - создаёт ECS request-компоненты,
  - подписывается на события ECS (окончание боя),
  - управляет состоянием UI.

- **MainMenuController**
  - формирует данные армий,
  - управляет логикой главного меню,
  - подготавливает данные для ECS-спавна.

---

#### UI-модель / сервисы
- **Cooldown**
  - универсальный MonoBehaviour-таймер,
  - управляет кулдауном способности,
  - уведомляет UI через события.

Cooldown реализован вне ECS, так как:
- не влияет на симуляцию,
- используется только на уровне интерфейса,
- снижает связность UI и gameplay.

---

### Entry Points

- **EntryPoint**
  - инициализация главного меню.

- **GameEntryPoint**
  - инициализация игрового UI,
  - создание `GameUiController` и связывание UI с gameplay.

---

### Итог архитектуры

- ECS используется для всех performance-критичных задач.
- UI полностью изолирован от ECS-реализации.
- Связь между слоями осуществляется через чётко определённые точки (requests и events).
- Архитектура масштабируема и пригодна для дальнейшего развития проекта.

 
